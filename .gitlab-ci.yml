stages:
  - prepare
  - test
  - build

variables:
  TARGET_BRANCH: "CICD_2"
  IMAGE_NAME: "git.fa.edu.vn/hcm25_cpl_net_06/team03_be/team03-webapi"
  GIT_STRATEGY: none
  GIT_USERNAME: "fsa_HongTL"

default:
  image: mcr.microsoft.com/dotnet/sdk:8.0

prepare:
  stage: prepare
  image: mcr.microsoft.com/dotnet/sdk:8.0
  rules:
    - if: $CI_COMMIT_BRANCH == $TARGET_BRANCH
  script:
    - apt-get update && apt-get install -y git curl jq
    - echo "Configuring Git credentials..."
    - git config --global credential.helper store
    - echo "https://${GIT_USERNAME}:${GIT_ACCESS_TOKEN}@git.fa.edu.vn" > ~/.git-credentials
    - git config --global user.name "$GIT_USERNAME"
    - git config --global user.email "$GIT_USERNAME@users.noreply.gitlab.com"
    - echo "Testing Git authentication..."
    - git ls-remote "http://git.fa.edu.vn/hcm25_cpl_net_06/team03_be.git" || echo "Authentication test failed, but continuing"
    - echo "Prepare stage completed successfully"
  tags:
    - cicd

build:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:8.0
  rules:
    - if: $CI_COMMIT_BRANCH == $TARGET_BRANCH
  before_script:
    - apt-get update && apt-get install -y openssh-client curl tar gzip git
    - echo "Configuring Git authentication..."
    - git config --global credential.helper store
    - echo "https://${GIT_USERNAME}:${GIT_ACCESS_TOKEN}@git.fa.edu.vn" > ~/.git-credentials
    - git config --global user.name "$GIT_USERNAME"
    - git config --global user.email "$GIT_USERNAME@users.noreply.gitlab.com"
    - echo "Cloning repository..."
    - git clone -b $TARGET_BRANCH "http://git.fa.edu.vn/hcm25_cpl_net_06/team03_be.git" project_source || exit 1
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - eval $(ssh-agent -s)
    - ssh-add ~/.ssh/id_rsa
    - ssh-keyscan -H vps.purintech.id.vn >> ~/.ssh/known_hosts 2>/dev/null || echo "SSH keyscan failed"
  script:
    - echo "Transferring source code to server for Docker build..."
    - echo "Preparing source code archive..."
    - cd project_source
    - tar -czf ../project.tar.gz .
    - cd ..
    - echo "Uploading source code to server..."
    - scp -o StrictHostKeyChecking=no project.tar.gz fsoftguy@vps.purintech.id.vn:~/project.tar.gz
    - |
      ssh -o StrictHostKeyChecking=no fsoftguy@vps.purintech.id.vn "
        echo 'Creating build directory...'
        BUILD_DIR=~/docker-builds/team03-build-\$(date +%Y%m%d-%H%M%S)
        mkdir -p \$BUILD_DIR
        echo \"Build directory: \$BUILD_DIR\"
        
        echo 'Moving source code to build directory...'
        cd \$BUILD_DIR
        mv ~/project.tar.gz .
        tar -xzf project.tar.gz
        rm project.tar.gz
        
        echo 'Setting up Docker environment...'
        export PATH=\"\$HOME/bin:\$PATH\"
        export DOCKER_HOST=\"unix:///run/user/\$(id -u)/docker.sock\"
        
        systemctl --user start docker.service 2>/dev/null || echo 'Docker service already running'
        sleep 3
        
        echo 'Testing Docker access...'
        if docker version > /dev/null 2>&1; then
          echo 'Rootless Docker accessible!'
          echo \"Docker version: \$(docker version --format '{{.Server.Version}}')\"
        else
          echo 'Docker not accessible!'
          echo 'Checking Docker service status:'
          systemctl --user status docker.service
          exit 1
        fi
        
        echo 'Checking Dockerfile...'
        if [ ! -f Dockerfile ]; then
          echo 'ERROR: Dockerfile not found!'
          ls -la
          exit 1
        fi
        
        echo 'Logging into GitLab Container Registry...'
        echo 'Skipping registry login - using local images only'
        
        echo 'Building Docker image...'
        docker build -t 'team03-webapi:latest' -t 'team03-webapi:$CI_COMMIT_SHA' .
        
        if [ \$? -eq 0 ]; then
          echo 'Docker build successful!'
          echo 'BUILD_STATUS=SUCCESS' > ~/build_status.txt
          
          echo 'Deploying immediately...'
          echo 'Force cleanup all containers and ports...'
          
          # Aggressive container cleanup - multiple strategies
          echo 'Step 1: Kill all containers with team03-webapi name...'
          docker ps -aq --filter name=team03-webapi | xargs -r docker kill 2>/dev/null || echo 'No named containers to kill'
          docker ps -aq --filter name=team03-webapi | xargs -r docker rm -f 2>/dev/null || echo 'No named containers to remove'
          
          echo 'Step 2: Kill containers using port 8080...'
          docker ps --format 'table {{.ID}}\t{{.Ports}}' | grep ':8080->' | awk '{print \$1}' | xargs -r docker kill 2>/dev/null || echo 'No port 8080 containers to kill'
          docker ps -a --format 'table {{.ID}}\t{{.Ports}}' | grep ':8080->' | awk '{print \$1}' | xargs -r docker rm -f 2>/dev/null || echo 'No port 8080 containers to remove'
          
          echo 'Step 3: Prune stopped containers...'
          docker container prune -f 2>/dev/null || echo 'Container prune completed'
          
          echo 'Step 4: Force cleanup any remaining processes...'
          # Kill any docker processes that might be hanging
          pkill -f 'docker.*team03-webapi' 2>/dev/null || echo 'No hanging docker processes'
          
          # Wait for cleanup to complete
          sleep 5
          
          echo 'Step 5: Final port check and cleanup...'
          if netstat -ln 2>/dev/null | grep ':8080 ' || ss -ln 2>/dev/null | grep ':8080 '; then
            echo 'WARNING: Port 8080 still occupied, attempting final cleanup...'
            # Find and kill any containers still using port 8080
            docker ps -q | xargs -r -I {} sh -c 'docker port {} 2>/dev/null | grep 8080 && docker kill {} || true'
            sleep 3
          else
            echo 'SUCCESS: Port 8080 is now available'
          fi
          
          echo 'Starting new container with retry logic...'
          CONTAINER_ID=\"\"
          RETRY_COUNT=0
          MAX_RETRIES=3
          
          while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
            echo \"Attempt \$((\$RETRY_COUNT + 1)) of \$MAX_RETRIES...\"
            
            CONTAINER_ID=\$(docker run -d \
              --name team03-webapi \
              -p 8080:8080 \
              --restart unless-stopped \
              team03-webapi:latest 2>/dev/null || echo \"\")
            
            if [ -n \"\$CONTAINER_ID\" ] && [ \"\$CONTAINER_ID\" != \"\" ]; then
              echo \"Container started successfully: \$CONTAINER_ID\"
              break
            else
              echo \"Failed to start container, attempt \$((\$RETRY_COUNT + 1)) failed\"
              RETRY_COUNT=\$((\$RETRY_COUNT + 1))
              
              if [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; then
                echo \"Retrying in 5 seconds...\"
                # Additional cleanup before retry
                docker kill team03-webapi 2>/dev/null || true
                docker rm team03-webapi 2>/dev/null || true
                sleep 5
              fi
            fi
          done
          
          if [ -z \"\$CONTAINER_ID\" ] || [ \"\$CONTAINER_ID\" = \"\" ]; then
            echo \"CRITICAL: Failed to start container after \$MAX_RETRIES attempts\"
            echo \"Port status:\"
            netstat -ln | grep 8080 || ss -ln | grep 8080 || echo \"No processes on port 8080\"
            echo \"Docker processes:\"
            docker ps -a
            echo 'BUILD_STATUS=DEPLOY_FAILED' > ~/build_status.txt
            exit 1
          fi
          
          echo 'Verifying deployment...'
          sleep 5
          if docker ps | grep \$CONTAINER_ID > /dev/null; then
            echo 'Container is running successfully!'
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep team03-webapi
            
            echo 'Checking application health...'
            sleep 10
            curl -f http://localhost:8080 > /dev/null 2>&1 && echo 'Application is responding!' || echo 'Application endpoint not available yet'
            
            echo ''
            echo '===== DEPLOYMENT SUCCESSFUL ====='
            echo 'Application URL: http://vps.purintech.id.vn:8080'
            echo 'API Base URL: http://vps.purintech.id.vn:8080/api'
            echo 'Swagger UI: http://vps.purintech.id.vn:8080/swagger'
            echo 'Health Check: http://vps.purintech.id.vn:8080/health'
            echo '=================================='
            echo 'Your application is now live and accessible!'
            echo 'BUILD_STATUS=SUCCESS' > ~/build_status.txt
            echo ''
          else
            echo 'Container failed to start!'
            echo 'Docker logs:'
            docker logs \$CONTAINER_ID 2>/dev/null || echo 'No logs available'
            echo 'Container status:'
            docker ps -a | grep team03-webapi || echo 'No container found'
            echo 'BUILD_STATUS=DEPLOY_FAILED' > ~/build_status.txt
          fi
        else
          echo 'Docker build failed!'
          echo 'BUILD_STATUS=BUILD_FAILED' > ~/build_status.txt
        fi
        
        echo 'Cleaning up build directory...'
        cd ~
        rm -rf \$BUILD_DIR
        
        echo 'Build process completed!'
      "
    - ssh -o StrictHostKeyChecking=no fsoftguy@vps.purintech.id.vn "cat ~/build_status.txt 2>/dev/null || echo 'BUILD_STATUS=UNKNOWN'" > build_status.txt
    - cat build_status.txt
  artifacts:
    reports:
      dotenv: build_status.txt
    expire_in: 1 hour
  tags:
    - cicd
