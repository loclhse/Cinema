stages:
  - prepare
  - test
  - build

variables:
  TARGET_BRANCH: "CICD_2"
  IMAGE_NAME: "git.fa.edu.vn/hcm25_cpl_net_06/team03_be/team03-webapi"
  GIT_STRATEGY: none
  GIT_USERNAME: "fsa_HongTL"

default:
  image: mcr.microsoft.com/dotnet/sdk:8.0

prepare:
  stage: prepare
  image: mcr.microsoft.com/dotnet/sdk:8.0
  rules:
    - if: $CI_COMMIT_BRANCH == $TARGET_BRANCH
  script:
    - apt-get update && apt-get install -y git curl jq
    - echo "Configuring Git credentials..."
    - git config --global credential.helper store
    - echo "https://${GIT_USERNAME}:${GIT_ACCESS_TOKEN}@git.fa.edu.vn" > ~/.git-credentials
    - git config --global user.name "$GIT_USERNAME"
    - git config --global user.email "$GIT_USERNAME@users.noreply.gitlab.com"
    - echo "Testing Git authentication..."
    - git ls-remote "http://git.fa.edu.vn/hcm25_cpl_net_06/team03_be.git" || echo "Authentication test failed, but continuing"
    - echo "Prepare stage completed successfully"
  tags:
    - cicd

build:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:8.0
  rules:
    - if: $CI_COMMIT_BRANCH == $TARGET_BRANCH
  before_script:
    - apt-get update && apt-get install -y openssh-client curl tar gzip git
    - echo "Configuring Git authentication..."
    - git config --global credential.helper store
    - echo "https://${GIT_USERNAME}:${GIT_ACCESS_TOKEN}@git.fa.edu.vn" > ~/.git-credentials
    - git config --global user.name "$GIT_USERNAME"
    - git config --global user.email "$GIT_USERNAME@users.noreply.gitlab.com"
    - echo "Cloning repository..."
    - git clone -b $TARGET_BRANCH "http://git.fa.edu.vn/hcm25_cpl_net_06/team03_be.git" project_source || exit 1
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - eval $(ssh-agent -s)
    - ssh-add ~/.ssh/id_rsa
    - ssh-keyscan -H vps.purintech.id.vn >> ~/.ssh/known_hosts 2>/dev/null || echo "SSH keyscan failed"
  script:
    - echo "Transferring source code to server for Docker build..."
    - echo "Preparing source code archive..."
    - cd project_source
    - tar -czf ../project.tar.gz .
    - cd ..
    - echo "Uploading source code to server..."
    - scp -o StrictHostKeyChecking=no project.tar.gz fsoftguy@vps.purintech.id.vn:~/project.tar.gz
    - |
      timeout 600 ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 fsoftguy@vps.purintech.id.vn "
        set -e
        echo 'Creating build directory...'
        BUILD_DIR=~/docker-builds/team03-build-\$(date +%Y%m%d-%H%M%S)
        mkdir -p \$BUILD_DIR
        echo \"Build directory: \$BUILD_DIR\"
        
        echo 'Moving source code to build directory...'
        cd \$BUILD_DIR
        mv ~/project.tar.gz .
        tar -xzf project.tar.gz
        rm project.tar.gz
        
        echo 'Setting up Docker environment...'
        export PATH=\"\$HOME/bin:\$PATH\"
        export DOCKER_HOST=\"unix:///run/user/\$(id -u)/docker.sock\"
        
        systemctl --user start docker.service 2>/dev/null || echo 'Docker service already running'
        sleep 3
        
        echo 'Testing Docker access...'
        if docker version > /dev/null 2>&1; then
          echo 'Rootless Docker accessible!'
          echo \"Docker version: \$(docker version --format '{{.Server.Version}}')\"
        else
          echo 'Docker not accessible!'
          echo 'Checking Docker service status:'
          systemctl --user status docker.service
          exit 1
        fi
        
        echo 'Checking Dockerfile...'
        if [ ! -f Dockerfile ]; then
          echo 'ERROR: Dockerfile not found!'
          ls -la
          exit 1
        fi
        
        echo 'Logging into GitLab Container Registry...'
        echo 'Skipping registry login - using local images only'
        
        echo 'Building Docker image...'
        docker build -t 'team03-webapi:latest' -t 'team03-webapi:$CI_COMMIT_SHA' .
        
        if [ \$? -eq 0 ]; then
          echo 'Docker build successful!'
          echo 'BUILD_STATUS=SUCCESS' > ~/build_status.txt
          
          echo 'Deploying immediately...'
          echo 'Enhanced cleanup and deployment process...'
          
          # Step 1: Stop and remove containers by name
          echo 'Stopping containers by name...'
          docker stop team03-webapi 2>/dev/null || echo 'Container not running'
          docker rm -f team03-webapi 2>/dev/null || echo 'Container not found'
          
          # Step 2: Find and stop ALL containers using port 8080
          echo 'Finding all processes and containers on port 8080...'
          
          # Kill processes using port 8080
          PIDS_ON_8080=\$(lsof -ti:8080 2>/dev/null || echo '')
          if [ -n \"\$PIDS_ON_8080\" ]; then
            echo \"Found PIDs on port 8080: \$PIDS_ON_8080\"
            echo \$PIDS_ON_8080 | xargs -r kill -9 2>/dev/null || echo 'Kill processes failed'
          fi
          
          # Alternative method using netstat and kill
          NETSTAT_PIDS=\$(netstat -tulpn 2>/dev/null | grep ':8080' | awk '{print \$7}' | cut -d'/' -f1 | grep -v '-' | sort -u || echo '')
          if [ -n \"\$NETSTAT_PIDS\" ]; then
            echo \"Found netstat PIDs on port 8080: \$NETSTAT_PIDS\"
            echo \$NETSTAT_PIDS | xargs -r kill -9 2>/dev/null || echo 'Kill netstat PIDs failed'
          fi
          
          # Clean up containers by port mapping  
          CONTAINERS_WITH_8080=\$(docker ps -a --format '{{.ID}} {{.Ports}}' | grep '8080' | awk '{print \$1}' || echo '')
          if [ -n \"\$CONTAINERS_WITH_8080\" ]; then
            echo \"Found containers with port 8080: \$CONTAINERS_WITH_8080\"
            echo \$CONTAINERS_WITH_8080 | xargs -r docker stop 2>/dev/null || echo 'Stop containers failed'
            echo \$CONTAINERS_WITH_8080 | xargs -r docker rm -f 2>/dev/null || echo 'Remove containers failed'
          else
            echo 'No containers found with port 8080 mapping'
          fi
          
          # Step 3: Force Docker system cleanup
          echo 'Docker system cleanup...'
          docker system prune -f --volumes 2>/dev/null || echo 'Docker cleanup failed'
          
          # Step 4: Wait longer and verify port is free
          echo 'Waiting for port to be released...'
          sleep 5
          
          echo 'Final port 8080 status:'
          PORT_CHECK=\$(netstat -ln | grep ':8080' || echo '')
          if [ -n \"\$PORT_CHECK\" ]; then
            echo 'WARNING: Port 8080 still in use!'
            echo \"\$PORT_CHECK\"
            echo 'Processes on port 8080:'
            lsof -i:8080 2>/dev/null || echo 'No processes found with lsof'
            netstat -tulpn 2>/dev/null | grep ':8080' || echo 'No netstat processes found'
            
            echo 'Attempting to use alternative port mapping...'
            ALT_PORT=8081
          else
            echo 'Port 8080 is now free'
            ALT_PORT=8080
          fi
          
          echo \"Starting new container on port \$ALT_PORT...\"
          CONTAINER_ID=\$(docker run -d \\
            --name team03-webapi \\
            -p \$ALT_PORT:8080 \\
            --restart unless-stopped \\
            team03-webapi:latest 2>&1)
          
          echo \"Container creation result: \$CONTAINER_ID\"
          
          if echo \"\$CONTAINER_ID\" | grep -E '^[a-f0-9]{12,}' > /dev/null; then
            echo \"Container started successfully with ID: \$CONTAINER_ID\"
            
            echo 'Waiting for container to stabilize...'
            sleep 10
            
            echo 'Checking container status...'
            CONTAINER_STATUS=\$(docker ps --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}' | grep team03-webapi || echo 'NOT_FOUND')
            if [ \"\$CONTAINER_STATUS\" != \"NOT_FOUND\" ]; then
              echo 'Container is running successfully!'
              echo \"\$CONTAINER_STATUS\"
              
              echo 'Testing application health...'
              sleep 8
              
              # Test application endpoint
              echo \"Testing localhost:\$ALT_PORT connection...\"
              HEALTH_CHECK=\$(curl -s -o /dev/null -w \"%{http_code}\" http://localhost:\$ALT_PORT 2>/dev/null || echo '000')
              echo \"Health check response code: \$HEALTH_CHECK\"
              
              if [ \"\$HEALTH_CHECK\" != \"000\" ] && [ \"\$HEALTH_CHECK\" != \"404\" ]; then
                echo 'Application is responding!'
              else
                echo 'Application not responding yet, checking logs...'
                docker logs team03-webapi 2>/dev/null | tail -15 || echo 'No logs available'
              fi
              
              # Display final URLs
              echo ''
              echo '===== DEPLOYMENT SUCCESSFUL ====='
              if [ \"\$ALT_PORT\" = \"8080\" ]; then
                echo 'Application URL: http://vps.purintech.id.vn:8080'
                echo 'API Base URL: http://vps.purintech.id.vn:8080/api'
                echo 'Swagger UI: http://vps.purintech.id.vn:8080/swagger'
                echo 'Health Check: http://vps.purintech.id.vn:8080/health'
              else
                echo \"Application URL: http://vps.purintech.id.vn:\$ALT_PORT\"
                echo \"API Base URL: http://vps.purintech.id.vn:\$ALT_PORT/api\"
                echo \"Swagger UI: http://vps.purintech.id.vn:\$ALT_PORT/swagger\"
                echo \"Health Check: http://vps.purintech.id.vn:\$ALT_PORT/health\"
                echo \"NOTE: Using alternative port \$ALT_PORT due to port 8080 conflict\"
              fi
              echo '=================================='
              echo 'Your application is now live and accessible!'
              echo 'BUILD_STATUS=SUCCESS' > ~/build_status.txt
            else
              echo 'ERROR: Container failed to start or crashed!'
              echo 'Container logs:'
              docker logs team03-webapi 2>/dev/null | tail -25 || echo 'No logs available'
              echo 'Container inspect:'
              docker inspect team03-webapi 2>/dev/null | jq '.[] | {State, Config.Env, NetworkSettings.Ports}' || echo 'Inspect failed'
              echo 'BUILD_STATUS=DEPLOY_FAILED' > ~/build_status.txt
            fi
          else
            echo \"CRITICAL ERROR: Failed to start container!\"
            echo \"Docker run output: \$CONTAINER_ID\"
            echo 'Checking Docker status:'
            docker ps -a | grep team03 || echo 'No team03 containers found'
            echo \"Checking port \$ALT_PORT availability:\"
            netstat -ln | grep \":\$ALT_PORT\" || echo \"Port \$ALT_PORT appears free\"
            echo 'BUILD_STATUS=DEPLOY_FAILED' > ~/build_status.txt
            exit 1
          fi
        else
          echo 'Docker build failed!'
          echo 'BUILD_STATUS=BUILD_FAILED' > ~/build_status.txt
        fi
        
        echo 'Cleaning up build directory...'
        cd ~
        rm -rf \$BUILD_DIR
        
        echo 'Build process completed!'
      "
    - ssh -o StrictHostKeyChecking=no fsoftguy@vps.purintech.id.vn "cat ~/build_status.txt 2>/dev/null || echo 'BUILD_STATUS=UNKNOWN'" > build_status.txt
    - cat build_status.txt
  artifacts:
    reports:
      dotenv: build_status.txt
    expire_in: 1 hour
  tags:
    - cicd
